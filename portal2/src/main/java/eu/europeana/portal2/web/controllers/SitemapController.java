package eu.europeana.portal2.web.controllers;

import java.io.*;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.annotation.Resource;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import eu.europeana.corelib.web.swift.SwiftProvider;
import org.apache.commons.lang.StringEscapeUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.time.DateUtils;
import org.apache.log4j.Logger;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.response.FacetField;
import org.apache.solr.client.solrj.response.FacetField.Count;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

import redis.clients.jedis.Jedis;
import eu.europeana.corelib.db.service.ThumbnailService;
import eu.europeana.corelib.definitions.edm.beans.BriefBean;
import eu.europeana.corelib.definitions.solr.DocType;
import eu.europeana.corelib.definitions.solr.model.Query;
import eu.europeana.corelib.edm.exceptions.EuropeanaQueryException;
import eu.europeana.corelib.edm.exceptions.SolrTypeException;
import eu.europeana.corelib.search.SearchService;
import eu.europeana.corelib.web.service.EuropeanaUrlService;
import eu.europeana.corelib.web.support.Configuration;
import eu.europeana.portal2.services.ClickStreamLogService;
import eu.europeana.portal2.services.impl.StaticPageCache;
import eu.europeana.portal2.web.controllers.statics.StaticPageController;
import eu.europeana.portal2.web.presentation.PortalPageInfo;
import eu.europeana.portal2.web.presentation.model.SearchPage;
import eu.europeana.portal2.web.presentation.model.SitemapPage;
import eu.europeana.portal2.web.presentation.model.data.decorators.BriefBeanDecorator;
import eu.europeana.portal2.web.presentation.model.data.submodel.ContributorItem;
import eu.europeana.portal2.web.presentation.model.data.submodel.SitemapEntry;
import eu.europeana.portal2.web.util.ControllerUtil;
import eu.europeana.portal2.web.util.keyvalue.RedisProvider;

/**
 * This class generates the XML sitemap files (the list of pages of a web site accessible to
 * crawlers) for the content of Europeana Portal. It follows the Sitemap Protocol v0.9
 * (http://www.sitemaps.org/protocol.html).<br>
 * It uses a Sitemap index file to group multiple sitemap files, to ensure the protocol limits of
 * 50,000 URLs and 10MB (10,485,760 bytes) filesize. Note that the Sitemap index file itself can
 * only include up to 50,000 Sitemaps (although 1,000 is another quoted figure!) and must not exceed
 * 10MB (10,485,760 bytes)
 * 
 * The sitemap index is generated by querying the {@link SearchService} using the id3hash facet,
 * which splits the records into groups based on the first 3 letters of their record identifiers.
 * Note that this is not a great hash selection, as there are many records that start with the same
 * identifier (the 'pathological data set', in this case 'Bibliography'). To adhere to the above
 * maximmum URL limits, a number of the id3hash groups are split across multiple sitemaps (and thus
 * multiple files in the sitemap index file).
 * 
 * @author Peter Kiraly, Bram Lohman
 * 
 */
@Controller
public class SitemapController {

  private final Logger log = Logger.getLogger(this.getClass());

  @Resource
  private Configuration config;

  @Resource
  private StaticPageCache staticPageCache;

  @Resource
  private SearchService searchService;

  @Resource
  private SwiftProvider swiftProvider;

  @Resource
  private RedisProvider redisProvider;


  private static final String SITEMAP_INDEX = "europeana-sitemap-index-hashed-";
  private static final String SITEMAP_HASHED = "europeana-sitemap-hashed-";

  private static final String XML = ".xml";



  private static String portalUrl;


  private static List<ContributorItem> contributorEntries;

  /**
   * Generate the Solr clause "COMPLETENESS:['min' TO *]", where 'min' is the lower bound of the
   * completeness clause
   * 
   * @param min The lower bound of the completeness clause
   * @return String containing the Solr clause
   */
  public static String solrCompletenessClause(int min) {
    return "COMPLETENESS:[" + min + " TO *]";
  }

  /**
   * Generate the sitemap index file. This file groups multiple sitemap files to adhere to the
   * 50,000 URLs / 10MB (10,485,760 bytes) sitemap limit. This index itself may not list more than
   * 50,000 Sitemaps and must be no larger than 10MB (10,485,760 bytes). The sitemaps are split by
   * id3hash (the first 3 letters of the record), and further split into files of maximum
   * MAX_URLS_PER_SITEMAP if these groups exceed 50,000 URLs.
   * 

   * @param response The {@link HttpServletResponse}
   * @throws IOException For any file-related exceptions
   */
  @RequestMapping("/europeana-sitemap-index-hashed.xml")
  public void handleSitemapIndexHashed(HttpServletResponse response) throws IOException {



   /** Jedis jedis = redisProvider.getJedis();
    // Return a 404 if the sitemap cache cannot be used
    if (!jedis.isConnected()) {
      response.setStatus(404);
      redisProvider.returnJedis(jedis);
      return;
    }*/


    String cacheFile = "europeana-sitemap-index-hashed.xml";
    // Generate the requested sitemap if it's outdated / doesn't exist (and is not currently being
    // created)
    if (( swiftProvider.getObjectApi().getWithoutBody(cacheFile)==null)) {
      boolean success = false;
      ServletOutputStream out = response.getOutputStream();


        log.error(String.format("Sitemap does not exist"));



    } else {

      // Read the sitemap from file
      readCachedSitemap(response.getOutputStream(), swiftProvider, cacheFile);
    }

  }

  /**
   * Generate the individual sitemaps, containing the actual record IDs. Each file needs to adhere
   * to the 50,000 URLs / 10MB (10,485,760 bytes) sitemap limit. Each sitemap is split by id3hash
   * (the first 3 letters of the record); an id3hash may be split over multiple files if there are
   * more than 50,000 records (the current implementation uses approx. 5.8 MB for 50,000 URLs, so
   * the size is not the limiting factor).
   * 

   * @param from start index
   * @param to end index
   * @param response The {@link HttpServletResponse}
   * @throws IOException
   */
  @RequestMapping("/europeana-sitemap-hashed.xml")
  public void handleSitemap(@RequestParam(value = "from", required = true) String from,
      @RequestParam(value = "to", required = true) String to, HttpServletResponse response)
      throws IOException {




    String cacheFile = "europeana-sitemap-hashed.xml" + "?from=" +from +"&to=" + to;

    if ( swiftProvider.getObjectApi().getWithoutBody(cacheFile)==null) {


      log.info(String.format("Error processing %s", cacheFile));


    } else {
      ServletOutputStream out = response.getOutputStream();
      readCachedSitemap(out,swiftProvider,cacheFile);
    }

  }







  /**
   * Lists the providers and the number of records they provide.
   * 
   * @param request The {@link HttpServletRequest}
   * @param locale The user's {@link Locale}
   * @return A ModelAndView containing the list of providers and number of records provided
   * @throws EuropeanaQueryException
   */
  @RequestMapping("/europeana-providers.html")
  public ModelAndView handleListOfContributors(HttpServletRequest request, Locale locale)
      throws EuropeanaQueryException {

    String portalServer = new StringBuilder(config.getPortalServer()).toString();

    // sitemap index - collections overview
    if ( contributorEntries == null) {
      contributorEntries = new ArrayList<ContributorItem>();
      List<Count> providers;
      try {
        providers = searchService.createCollections("PROVIDER", "*:*");
        for (Count provider : providers) {
          try {
            String query =
                StringEscapeUtils.escapeXml(String.format("search.html?query=*:*&qf=PROVIDER:%s",
                    convertProviderToUrlParameter(provider.getName())));
            ContributorItem contributorItem =
                new ContributorItem(query, provider.getName(), provider.getCount(), portalServer);

            List<ContributorItem.DataProviderItem> dataProviders =
                new ArrayList<ContributorItem.DataProviderItem>();

            List<Count> rawDataProviders =
                searchService.createCollections("DATA_PROVIDER", "*:*",
                    "PROVIDER:\"" + provider.getName() + "\"");
            for (Count dataProvider : rawDataProviders) {
              if (dataProvider.getCount() > 0) {
                dataProviders.add(contributorItem.new DataProviderItem(contributorItem,
                    dataProvider.getName(), dataProvider.getCount()));
              }
            }

            contributorItem.setDataProviders(dataProviders);
            contributorEntries.add(contributorItem);
          } catch (UnsupportedEncodingException e) {
            log.warn(e.getMessage() + " on " + provider.getName());
          }
        }
      } catch (SolrTypeException e1) {
        e1.printStackTrace();
      }
    }

    SitemapPage<ContributorItem> model = new SitemapPage<ContributorItem>();
    model.setResults(contributorEntries);
    model.setPrefix("");
    model.setLeftContent(getStaticPagePart("/newcontent.html",
        StaticPageController.AFFIX_TEMPLATE_VAR_FOR_LEFT, locale));

    ModelAndView page =
        ControllerUtil.createModelAndViewPage(model, locale, PortalPageInfo.PROVIDERS);
   // clickStreamLogger.logUserAction(request, ClickStreamLogService.UserAction.SITE_MAP_XML, page);
    return page;
  }

  /**
   * Returns an XML sitemap representation containing an URL of the
   * {@link SitemapController#handleListOfContributors(HttpServletRequest, Locale)}
   * 
   * @param request
   * @return ModelAndView
   */
  @RequestMapping("/europeana-sitemap-static.xml")
  public ModelAndView handleSitemap(HttpServletRequest request) {

    List<SitemapEntry> records = new ArrayList<SitemapEntry>();
    records
        .add(new SitemapEntry("http://www.europeana.eu/europeana-providers.html", null, null, 10));

    SitemapPage<SitemapEntry> model = new SitemapPage<SitemapEntry>();
    model.setResults(records);
    model.setShowImages(false);

    ModelAndView page = ControllerUtil.createModelAndViewPage(model, PortalPageInfo.SITEMAP);
    //clickStreamLogger.logUserAction(request, ClickStreamLogService.UserAction.SITE_MAP_XML, page);
    return page;
  }

  public static String convertProviderToUrlParameter(String provider)
      throws UnsupportedEncodingException {
    String url = URLEncoder.encode(provider.replace("\"", "\\\"").replace("/", "\\/"), "UTF-8");
    return url;
  }

  /**
   * Replace the periods ('.') in fileName with underscore, partName and period
   * 
   * @param fileName
   * @param partName
   * @param language
   * @return The replaced string
   */
  private String getStaticPagePart(String fileName, String partName, Locale language) {

    if (!StringUtils.isEmpty(partName)) {
      fileName = StringUtils.replaceOnce(fileName, ".", "_" + partName + ".");
    }

    return staticPageCache.getPage(fileName, language);
  }

  /**
   * Provide the string representation of the Portal URL, including forward slash
   * 
   * @return
   */
  private String getPortalUrl() {
    if (portalUrl == null) {
      portalUrl = config.getPortalServer();
      if (!portalUrl.endsWith("/")) {
        portalUrl = portalUrl + "/";
      }
    }
    return portalUrl;
  }

  /**
   * Read a cached sitemap, and copy its content to the output stream
   * 
   * @param out
   * @param cacheFile
   */
  private void readCachedSitemap(ServletOutputStream out, SwiftProvider swiftProvider, String cacheFile) {
    try {
      String s = swiftProvider.getObjectApi().get(cacheFile).getPayload().getRawContent().toString();


      out.println(s);
      out.flush();
    } catch (IOException e) {

    }
  }


}
